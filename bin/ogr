#!/usr/bin/perl

#
# Ogr - The anonymous, static, gradebook generator.
#
# Copyright 2018 Harlan J. Waldrop <harlan@ieee.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

use strict;
use warnings qw( all );

use File::Basename;
use lib dirname(__FILE__);

use Ogr::Emojis;
use Ogr::Gradebook;
use Ogr::Importer;

use Data::Dumper;
use DBI;
use Getopt::Long;
use Switch;
use YAML;

# Load shared settings
my $settings = YAML::LoadFile(dirname(__FILE__) . '/../settings.yml');
my $db_path = $settings->{database}{path};

# Command-line arguments (global settings)
my $sub = '';   # Sub-routine to run, e.g., build, import
my $from = '';  # Input file used in sub-routine
my $token = ''; # Path to token file used for external APIs, e.g., Canvas
my $slots = 0;  # Number of assignment slots to be created during import

my @args;       # Remaining command-line arguments

# This function is used to collect all command line arguments before running
# process_args()
sub push_arg
{
	my ( $arg ) = @_;

	push @args, $arg;
}

# Triggers the sub-routine indicated by $sub
sub process_args
{
	my ( $sub, $out ) = @args;

	# All of the sub-routines depend on the database
	die "Database ($db_path) does not exist... invalid path?" if !(-f $db_path);

	switch ($sub)
	{
		case "config" { config($out); }
		case "build"  { build($out); }
		case "import" { import($out); }
	}
}

sub config
{
	my $out = shift;

	if ($out eq '' || $from eq '')
	{
		return;
	}

	open my $fh, '>', $out
		or die "Could not open $out\n";

	my $php = '';

	$php .= "<?php\n\n";
	$php .= "// Automatically generated by Ogr on " . localtime(time) . "\n\n";
	$php .= "const AUTH = array(\n";
	while (my ($k, $v) = each $settings->{www}{auth})
	{
		if ($v !~ /^[+-]?\d+$/)
		{
			$v = "'$v'";
		}

		$php .= "\t'$k' => $v,\n";
	}
	$php .= "\t'database' => '$settings->{database}{path}'\n";
	$php .= ");\n";

	print $fh $php;
}

sub build
{
	my $out = shift;

	if ($out eq '' || $from eq '')
	{
		return;
	}

	my $gb = new Ogr::Gradebook($from, $out, $db_path);
	$gb->build();
}

sub import
{
	my $out = shift;

	if ($out eq '' || $from eq '' || $token eq '')
	{
		return;
	}

	my $handle = DBI->connect("dbi:SQLite:dbname=" . $db_path, "", "")
		or die "Could not connect to " . $db_path . "\n";

	open my $fh, '>', $out
		or die "Could not open $out\n";

	# A call to Importer may or may not generate dialog
	my $importer = new Ogr::Importer($from, $token);
	my $data = $importer->build();

	my $class = lc($data->{class});
	my $section = $data->{section};
	my @logins = @{ $data->{logins} };

	print $fh generate_file_header($class, $section, $slots);

	my %seen;
	my @set = ('0' .. '9', 'A' .. 'F');

	for (@logins)
	{
		# Generates a UNIQUE 4-byte hexadecimal identity for each user
		my $fprint = join '' => map $set[rand @set], 1 .. 8;
		redo if $seen{$fprint}++;

		# Grabs a UNIQUE user id from the Importer build which should be
		# in the form username@foo.bar for all users. Currently user
		# emails are not stored since typically all users are registered
		# under the schools email system, e.g., user@oregonstate.edu
		my ($id) = $_ =~ /([a-z0-9]+)$settings->{email_suffix}/i;
		my @emoji = emoji_rand();

		my $row = "'$id','$fprint','$emoji[0]','$emoji[1]',NULL,'$class','$section'";

		my $query = $handle->prepare("INSERT INTO students VALUES ($row)");
		$query->execute();

		# The expectation is that usernames are less than 16 characters.
		# For formatting reasons, names less than 1 (one) tab-width will
		# need an additional tab.
		#
		# Names longer than 16 characters will only break the initial
		# formatting generated here.
		if (length($id) == 8)
		{
			print $fh "$id";
		}
		else
		{
			print $fh "$id\t";
		}

		# Fill assignment grades with the empty character ('-')
		print $fh tabfill("-", $slots);
	}

	close $fh;
	$handle->disconnect();
}

sub generate_file_header
{
	my ($class, $section, $slots) = @_;

	my $br = "+";
	for (1 .. $slots + 2)
	{
		$br .= "--------";
	}
	$br .= "\n";

	# Title
	my $header = "title\t$class-$section gradebook\n";
	$header .= $br;

	my $fill = tabfill('', $slots);

	# Assignment Names
	$header .= "headers\t";
	$header .= $fill;
	$header .= $br;
	# Assignment Settings
	$header .= "due\t";
	$header .= $fill;
	$header .= "outof\t";
	$header .= $fill;
	$header .= $br;
	# Assignment Options
	$header .= "mute\t";
	$header .= tabfill('n', $slots);
	$header .= $br;

	return $header;
}

sub tabfill
{
	my ($str, $i) = @_;

	my $tab = '';

	for (1 .. $i)
	{
		$tab .= "\t$str";
	}
	$tab .= "\n";

	return $tab;
}

GetOptions(
	'from|f=s' =>\$from,
	'token|t=s' => \$token,
	'slots|s=s' => \$slots,
	'<>' =>\&push_arg
);

process_args();

__END__

=head1 ogr-cli

Command-line tooling for Ogr

=head1 SYNOPSIS

Ogr is an anonymous, static, gradebook generator.

=over 8

=item B<config> - Generate PHP configuration from settings file

=item B<build> - Generate a static webpage from the csv file

=item B<import> - Import and register a class list from an external source

=back

=head1 USAGE

=over 8

=item ogr config --from settings.yml www/config.php

=item ogr build --from gradebook.csv gradebook.html

=item ogr import --from canvas --token oauth2.token --slots 5 gradebook.csv

=back

=head1 LICENSE

Ogr is released under the Apache License, Version 2.0.

=head1 AUTHOR

Harlan J. Waldrop <harlan@ieee.org>

=cut
